/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.android.apis.graphics;

import android.content.Context;
import android.graphics.*;
import android.os.Bundle;
import android.view.View;

/**
 * Shows the results of using Matrix.ScaleToFit.FILL, Matrix.ScaleToFit.START, Matrix.ScaleToFit.CENTER,
 * and Matrix.ScaleToFit.END as the ScaleToFit options when calling:
 * <p>
 * Matrix.setRectToRect(Rect srcRect, Rect dstRect, Matrix.ScaleToFit stf)
 */
public class ScaleToFit extends GraphicsActivity {

    /**
     * Called when the activity is starting. First we call through to our super's implementation of
     * {@code onCreate}, then we set our content view to a new instance of {@code SampleView}.
     *
     * @param savedInstanceState we do not override {@code onSaveInstanceState} so do not use.
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(new SampleView(this));
    }

    /**
     * Custom view which generates and displays 4 ovals created with different bounding rectangles,
     * then proceeds to demonstrate the results of displaying each using {@code setRectToRect} into
     * a square using the four different types of {@code Matrix.ScaleToFit} options.
     */
    private static class SampleView extends View {
        /**
         * {@code Paint} used to draw all our ovals.
         */
        private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        /**
         * {@code Paint} used to draw the square we are fitting our ovals into.
         */
        private final Paint mHairPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        /**
         * {@code Paint} we use to draw the label on each of the four rows of scaled examples.
         */
        private final Paint mLabelPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        /**
         * {@code Matrix} we use to scale and translate values to map the ovals to the destination
         * square (generated by {@code setRectToRect}).
         */
        private final Matrix mMatrix = new Matrix();
        /**
         * {@code RectF} we use as the bounding rectangle for the ovals drawn by {@code drawOval},
         * and as the source rectangle to map from when calling {@code setRectToRect}
         */
        private final RectF mSrcR = new RectF();

        /**
         * The four different {@code Matrix.ScaleToFit} options passed to {@code setRectToRect}.
         */
        private static final Matrix.ScaleToFit[] sFits =
                new Matrix.ScaleToFit[]{
                        Matrix.ScaleToFit.FILL, // Scale in X and Y independently, so that src matches dst exactly.
                        // This may change the aspect ratio of the src.
                        Matrix.ScaleToFit.START, // Compute a scale that will maintain the original src aspect ratio,
                        // but will also ensure that src fits entirely inside dst. At least one axis (X or Y) will fit
                        // exactly. START aligns the result to the left and top edges of dst.
                        Matrix.ScaleToFit.CENTER, // Compute a scale that will maintain the original src aspect ratio,
                        // but will also ensure that src fits entirely inside dst. At least one axis (X or Y) will fit
                        // exactly. The result is centered inside dst.
                        Matrix.ScaleToFit.END // Compute a scale that will maintain the original src aspect ratio, but
                        // will also ensure that src fits entirely inside dst. At least one axis (X or Y) will fit exactly.
                        // END aligns the result to the right and bottom edges of dst.
                };

        /**
         * The labels corresponding to the {@code Matrix.ScaleToFit} option used for a row.
         */
        private static final String[] sFitLabels = new String[]{"FILL", "START", "CENTER", "END"};

        /**
         * Contains the width, height and color used to draw our 4 ovals.
         */
        private static final int[] sSrcData = new int[]{
                80, 40, Color.RED,
                40, 80, Color.GREEN,
                30, 30, Color.BLUE,
                80, 80, Color.BLACK
        };
        /**
         * Number of ovals we draw.
         */
        private static final int N = 4;

        /**
         * Scale to convert dp to pixels.
         */
        private float mScale;
        /**
         * Width of the destination rectangle for our drawing, modified by our constructor to scale
         * for the current display density
         */
        private static int WIDTH = 52;
        /**
         * Height of the destination rectangle for our drawing, modified by our constructor to scale
         * for the current display density
         */
        private static int HEIGHT = 52;
        /**
         * Destination rectangle that we draw into.
         */
        private RectF mDstR;

        /**
         * Our constructor. First we call our super's constructor, then we set our field {@code mScale}
         * to the value needed to dp units to pixel by fetching the resources associated with this view
         * and using that to access the {@code density} field of the current display metrics. We then
         * use {@code mScale} to scale our fields {@code WIDTH} and {@code HEIGHT}. We allocate a new
         * instance of {@code RectF} with width {@code WIDTH} and height {@code HEIGHT} for our field
         * {@code mDstR}, set the style of our field {@code Paint mHairPaint} to STROKE, and the text
         * size of {@code Paint mLabelPaint} to {@code 16 * mScale}.
         *
         * @param context {@code Context} to access resources.
         */
        public SampleView(Context context) {
            super(context);

            mScale = getResources().getDisplayMetrics().density;
            WIDTH = (int) mScale * WIDTH;
            HEIGHT = (int) mScale * HEIGHT;

            mDstR = new RectF(0, 0, WIDTH, HEIGHT);
            mHairPaint.setStyle(Paint.Style.STROKE);
            mLabelPaint.setTextSize(16 * mScale);
        }

        /**
         * Sets the width and height of {@code RectF mSrcR} to that of the oval whose data is fetched
         * from {@code final int[] sSrcData} given the value of our parameter {@code index}. The width
         * {@code int w} is to be found at location {@code index*3}, and the height {@code int h} is
         * to be found at {@code index*3+1}. Having fetched them we simply call the {@code set} method
         * of {@code mSrcR} to set its coordinates to these values.
         *
         * @param index which of the 4 ovals to use for the contents of {@code RectF mSrcR}.
         */
        private void setSrcR(int index) {
            @SuppressWarnings("PointlessArithmeticExpression")
            int w = sSrcData[index * 3 + 0];
            int h = sSrcData[index * 3 + 1];
            mSrcR.set(0, 0, w, h);
        }

        /**
         * After fetching the color of the oval specified by {@code index} from {@code int[] sSrcData}
         * and using it to set the color of {@code Paint mPaint}, we draw the oval whose width and height
         * has already been set in {@code RectF mSrcR} on the {@code Canvas canvas} using {@code mPaint}
         * as the {@code Paint}.
         *
         * @param canvas {@code Canvas} to draw on
         * @param index  oval number, we use it to fetch the color for this oval from {@code int[] sSrcData}
         */
        private void drawSrcR(Canvas canvas, int index) {
            mPaint.setColor(sSrcData[index * 3 + 2]);
            canvas.drawOval(mSrcR, mPaint);
        }

        /**
         * Pre-concatenates the {@code Canvas canvas} matrix with a matrix intended to scale and
         * translate values that map the source rectangle {@code RectF mSrcR} to the destination
         * rectangle {@code RectF mDstR} given the {@code Matrix.ScaleToFit} option {@code stf},
         * and draws the oval chosen by the parameter {@code index} to the canvas.
         * <p>
         * First we save the current matrix and clip of {@code canvas} onto a private stack, then we
         * call our method {@code setSrcR} to configure {@code RectF mSrcR} for the data for oval
         * {@code index}. We use the method {@code setRectToRect} to create in {@code Matrix mMatrix}
         * a matrix intended to scale and translate values that map the source rectangle
         * {@code RectF mSrcR} to the destination rectangle {@code RectF mDstR} given the {
         *
         * @param canvas {@code Canvas} to draw on
         * @param index  Number of the oval to draw
         * @param stf    {@code Matrix.ScaleToFit} option to use in call to {@code setRectToRect}
         * @code Matrix.ScaleToFit} option {@code stf}, and pre-concatenate it to the current matrix
         * of {@code canvas}. We then call our method {@code drawSrcR} to draw the {@code index} oval
         * to {@code canvas} using the correct color, and restore the matrix and click of {@code canvas}
         * to the state it was in before our call to {@code save}. Finally we draw an outline of the
         * destination rectangle {@code mDstR} using the {@code Paint mHairPaint}.
         */
        private void drawFit(Canvas canvas, int index, Matrix.ScaleToFit stf) {
            canvas.save();

            setSrcR(index);
            mMatrix.setRectToRect(mSrcR, mDstR, stf);
            canvas.concat(mMatrix);
            drawSrcR(canvas, index);

            canvas.restore();

            canvas.drawRect(mDstR, mHairPaint);
        }

        /**
         * We implement this to do our drawing. First we set the entire {@code Canvas canvas} to the
         * color WHITE, then we move it to the location (10,10), and save the current matrix and clip
         * onto a private stack. Then for each of our {@code N} ovals, we call our method {@code setSrcR}
         * to set the coordinates of {@code mScrR} for that oval, and using our method {drawSrcR} draw
         * the oval to the canvas. We then move the canvas to the right by the width of {@code mSrcR}
         * with an additional 15 pixels for spacing. When done drawing the ovals we restore the state
         * of the canvas to that it had before our call to save.
         * <p>
         * Now we move the {@code Canvas canvas} down 100 pixels and for each of the four scale to fit
         * options contained in {@code Matrix.ScaleToFit[] sFits} we first save the canvas matrix to
         * its private stack. Then for each of the four ovals we call our method {@code drawFit} to
         * scale and translate the oval then draw it into {@code RectF mDstR}, and move the canvas to
         * the right by the width of {@code mDstR} with an 8 pixel spacing to get ready for the next
         * oval. When done with the ovals for this row we draw the text describing the scale to fit
         * option that was used for that row, restore the canvas matrix to the state before our call
         * to save, and move the canvas down by {@code HEIGHT+20} for the next row.
         *
         * @param canvas the canvas on which the background will be drawn
         */
        @Override
        protected void onDraw(Canvas canvas) {
            canvas.drawColor(Color.WHITE);

            canvas.translate(10, 10);

            canvas.save();
            for (int i = 0; i < N; i++) {
                setSrcR(i);
                drawSrcR(canvas, i);
                canvas.translate(mSrcR.width() + 15, 0);
            }
            canvas.restore();

            canvas.translate(0, 100);
            for (int j = 0; j < sFits.length; j++) {
                canvas.save();
                for (int i = 0; i < N; i++) {
                    drawFit(canvas, i, sFits[j]);
                    canvas.translate(mDstR.width() + 8, 0);
                }
                canvas.drawText(sFitLabels[j], 0, HEIGHT * 2 / 3, mLabelPaint);
                canvas.restore();
                canvas.translate(0, HEIGHT + 20);
            }
        }
    }
}
